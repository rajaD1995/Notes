movie rating practice.
	-First access the data by- pd.read_csv(r'...../name.csv')
	-Load data by head() or tail()
	-column names- movie.columns
	* Slicing
	-movies[['title','genres']].head() #more than one column slicing with row slicing.
	-.iloc[row1:row2,column1:column2] or iloc[:,[0,5,9]]-->all rows, 0,5,9 index columns(specific columns). #column slicing.
	-.loc[row1:row2] --> row slicing--> .iloc[1:3] --> df[1:3]
	-.loc[[0,4,9]]   ---> give specific rows.same for iloc[[]]
	-clean_data[0:6:2] --> 0 to 5 index rows with step 2 ie 0, 2, 4 rows.

	-Check if names of attributes are correct, readable for all.
		-changing the columns name:
			-(i) movie = movie.set_axis(labels=['Film', 'Genre', 'CriticsRating', 'AudienceRatings','BudgetMillion', \
                               'Year of release'],axis=1)
			-(ii) movie.rename(columns={'Rotten Tomatoes Ratings %' : 'CriticsRating', 'Audience Ratings %' : 'AudienceRatings'},inplace=True)
			-(iii) movie.columns=['Film', 'Genre', 'CriticsRating', 'AudienceRatings', 'BudgetMillion','Year']
-Remove columns.
		-health = health.drop(columns=health.columns[[14, 15, 16]])  # Dropping by index
		-health = health.drop(columns=[14, 15, 16])  # Only works if 14, 15, 16 are column names.
		-If you want to modify the DataFrame without reassigning, use:
			-health.drop(columns=health.columns[[14, 15, 16]], inplace=True)
			-health.drop(columns=health.columns[[-1]]) -- it will remove last column but dataframe will not change.
		-iloc[:,[0,5,9]]-->all rows, 0,5,9 index columns(specific columns).
		-delete a column: # Dropping by name
        	i) rating_1 = rating.drop('timestamp',axis=1)
        	ii) del tag['timestamp']
        	iii) tag = tag.dropna()  #remove all rows having na or empty value.

	-storing column names
            column_0 = tag.columns[0]
    	-extract or store a specific column
            column0 = tag['userId']

-Filter
        filter1 = rating_1['rating'] > 10
        print(filter1) #print in false or true
        filter1.any() #give True if at least one value is >10
        filter2.all()  #all true then true.

	-#slicing by filter and row
        is_highly_rated = rating_1['rating'] >= 5.0
        rating_1[is_highly_rated][30:50]

	-#is_action is a dataframe not series. Gives list of movies having a word 'Action'
        is_action = movies['genres'].str.contains('Action')  #filtering as per a specific key word.
        movies[is_action][5:7]
	
	-for multiple data points
	filtered_data = sales_data[sales_data['unit_sold'].isin([17, 21])]
	filtered_data = sales_data.query('unit_sold in [17, 21]')

-asending or desending order
	rating.sort_values(by="rating") #rating column will be rearranged in asending order so as the data frame

-count
	-#count of occurance of a specific key word.
	-I want to find how many movies contain 'action' word and how any don't.
            is_action_count_count = movies[['genres']].groupby(is_action).count()
	
	- rating.sort_values(by="rating") #rating column will be rearranged in asending order so as the data frame
	-df.sort_values(by=['Age', 'Salary'], ascending=[True, False]) --> we can add more attributes.

	-#count = You have a dataset which have a attribute expanditure. You want to find the expanditure value which repeat maximum.
	By creating new dataframe
	mth_exp_tmp = pd.crosstab(index=income_df["Mthly_HH_Expense"], columns="count")
	mth_exp_tmp.reset_index(inplace=True)
	mth_exp_tmp[mth_exp_tmp['count'] == income_df.Mthly_HH_Expense.value_counts().max()]

	-or

	max_freq = sales_data[['unit_sold','category']].groupby('unit_sold').count() #dataframe
	max_freq.reset_index(inplace=True)
	max_freq.rename(columns = {'category': 'counts'},inplace=True)
	max_freq[max_freq['counts']==max_freq['counts'].max()]

-count- only word
-difference between count() and value_counts()
	sales_data.groupby('category')['product_ID'].count()--- Gives the count of product_ID per category.
category
Clothing       1
Electronics    4
Home           9
Sports         6

-value_counts()
	sales_data.groupby('category')['product_ID'].value_counts()
	sales_data.groupby(['category', 'product_ID']).size().reset_index(name='count') -- dataframe
		-- This does not give the count of product_ID for each category.
		-Rather it will give the no of unique values for each combination of category and product_ID
	
category     product_ID  Unique value
Clothing     10            1
Electronics  3             1
             7             1
             8             1
             16            1
Home         1             1
             4             1
             5             1
             9             1
             11            1
             12            1
             13            1
             14            1
             20            1
Sports       2             1
             6             1
             15            1
             17            1
             18            1
             19            1

-compare of value_counts & count()
	income_df["Highest_Qualified_Member"].value_counts().to_frame().T -- It can counts without groupby-- it gives count of unique values.

Highest_Qualified_Member	Graduate	Under-Graduate	Professional	Post-Graduate	Illiterate
count	                        19	         10	           10	           6	            5

	But
	income_df["Highest_Qualified_Member"].count().to_frame().T -- It can not count, because it only count with combination.
		-error

	income_df.groupby('Highest_Qualified_Member')["Mthly_HH_Income"].count().reset_index(name="count").T
		-it will count the frequency of the unique value of Highest_Qualified_Member attribute with the help of Mthly_HH_Income attribute
		-we can use any attribute inplace of Mthly_HH_Income.


-data cleaning & pre-processing:(remove functon is missing)

	-replace: movie.columns=movie.columns.str.replace(" ", "_")--->Year of release---->Year_of_release
	-movie.info() --- data type and memory used.
	-movie.dtype -- for streamlit.
	-data.shape --- (row, column)
	
	-If rows include unwanted charecters.
	-Data clean:
	-emp['Name'] = emp['Name'].str.replace(r'\W','',regex=True) - replace any special charecter to nothing
	-emp['Age'] = emp['Age'].str.extract('(\d+)') - It will extract numbers only, in continuation.
	
	-If attributes have null values.(EDA)
		-movie.isnull().any().any() #no null values in entire table
		-movie.isnull().sum() #imporant to know number of null valus per attributes.(check)
		-clean_data['Location'] = clean_data['Location'].fillna(clean_data['Location'].mode()[0]) - for categorical data
		-clean_data['Exp'] = clean_data['Exp'].fillna(np.mean(pd.to_numeric(clean_data['Exp']))) - for numerical data
	-#variable creation. (0 or 1)
		imputation = pd.get_dummies(clean_data,dtype=int) #for dtype=int we get class variable as 0 or 1 else true or false.

	-You want to remove special charecters or any type of data from a column but want to store it in a different column rather than deleting it.
		-import re
		# Function to extract special characters
		def extract_special_chars(name):
    			return ''.join(re.findall(r'\W', str(name)))  # Extracts all non-word characters
		# Create a new column for special characters
		emp1["Special_Chars"] = emp1["Name"].apply(extract_special_chars) --> apply function apply a method or funtion to all rows of column or all rows of all columns.

		-#I want to remove special char from name column & place the Special_chars column just adjacent to Name column
		# Remove special characters from the "Name" column
		emp1["Name"] = emp1["Name"].str.replace(r'\W', '', regex=True)
	-Reorder columns to place "Special_Chars" after "Name"
		column_order = ["Name", "Special_Chars"] + [col for col in emp1.columns if col not in ["Name", "Special_Chars"]]
		emp1 = emp1[column_order]
		emp1.head()

	-changing data type in one go.
		-using loop and condition to change the dtype of attributes.
		for col in movie.columns:
    			if movie[col].dtype == 'object':
        			movie[col] = movie[col].astype('category')
		-In oneline
			 -movie = movie.apply(lambda col: col.astype('object') if col.dtype == 'category' else col)
	-for only one column.
		-movie['Year']=movie['Year'].astype('category')
		-movies.Film = movies.Film.astype('category')

	-Statistical report- movie.describe().T

-Unique values

	1. How many unique values for a column
		-movie.Genre.nunique()
		-health['cp'].nunique()
	2. What are the uniques values in a column.
		-movie.Year.cat.categories  #for loop specially.
		-movie.Genre.unique()
		-health['age'].unique()
	3. How many unique values in each columns.
		-health.nunique()

	4. What are the unique values of each columns.
		-health.apply(pd.unique)
		-unique_values = {col: health[col].unique() for col in health.columns}  #datframe to dictory
		for col, values in unique_values.items():
    			print(f"Unique values in '{col}': {values}")
	5. what is the count of each unqiue value in a column or each column.
		-index, counts = np.unique(rating['rating'].values,return_counts=True) #gives no of repeation of each unique value of ratigs.Like no of time 1 is repeated.
		df = pd.DataFrame({
		    'rating': index,
		    'count': counts
		})
		print(df)
		-If you want to get unique values along with their counts of each columns, use:
		for col in health.columns:
    			print(f"Column: {col}")
    			print(health[col].value_counts())
    			print("-" * 30)

		-rating_1.groupby('rating').count() -- The item ie rating values will arranged in desending order.
		-health['cp'].value_counts() or health.cp.value_counts() -- The counts will be in desending order.
		-rating_1[['movieId','rating']].groupby('movieId').count() -- count each movie getting how many ratings with column slicing. == rating_1['movieId'].value_counts()
        	-average_rating = rating_1[['movieId','rating']].groupby('movieId').mean() -- count() --> then gives count.	

	6. What is the count of the uniques values of a column's unique vaues for other column's or columns' unqie value.
		-health.groupby('sex')['target'].value_counts()  #gives no of repeation of uniques values of 'target' for each 'sex'
		-health.groupby(['fbs','sex','cp'])['target'].value_counts() #gives no of repeation of uniques values of 'target' for each 'fbs','sex','cp'.

		-health.groupby('sex')['target'].value_counts(normalize=True) -- gives fraction of repeation of uniques values of 'target' for each 'sex'.
		-health.groupby('sex')['target'].value_counts(normalize=True).mul(100) -- multiply with 100 gives % value rather total count.

		-health.unique() -- Gives error. so use below code.
		-health.value_counts() -- then it gives the no of combination of each attributes. It must be used for a column.
		* count the occurrences of each unique value in the health column (or Series). 
			It returns a sorted Series with unique values as the index and their respective counts as values.

	7. Agrgate:
-Above one is just count not aggregate. Like you have one column of 4 category product and another column having the number of unit sold.
Now if you apply above then it will give you the count I mean the number of time category repeats but we want to add values present in unit sold column
for each category

sales_data.groupby('category')['unit_sold'].agg(['sum']) 
	
category	sum
Clothing	21
Electronics	73
Home		181
Sports		101

	
	-It will give mean, sum and max of both income and expanditure for each Highest_Qualified_Member unique item.
	grouped_data = income_df.groupby("Highest_Qualified_Member").agg({
    		'Mthly_HH_Income': ['mean', 'sum', 'max'],
    		'Mthly_HH_Expense': ['mean', 'sum', 'min']
	})

	print(grouped_data)

-.value_counts() arrange as per no of occurance and groupby() arrange in asending order of item ie here rating's value.
		-s.value_counts()	Counts unique values in a Series
		df['col'].value_counts() -- Counts unique values in a specific column of a DataFrame.
		s.value_counts(ascending=True) -- Sorts the counts in ascending order.
		s.value_counts(dropna=False) -- Includes NaN values in the count.
		s.value_counts(normalize=True) -- Returns relative frequencies instead of counts.
		s.value_counts(bins=3) -- Groups numerical values into 3 bins.
		df.value_counts() -- Counts unique row combinations in a DataFrame.

-mapping in groupby() & value_count(). By doing this sex instead of 0 or 1 it will display as male or female.
		target_label = {0 : 'No Heart Disease', 1 : 'Heart Disease'}
		sex_label = {0 : 'Female', 1 : 'Male'}
		# Create mapped columns (without modifying original data)
		health['sex_mapped'] = health['sex'].map(sex_label)
		health['target_mapped'] = health['target'].map(target_label)
		# Now group by mapped columns
		result = health.groupby('sex_mapped')['target_mapped'].value_counts()
		print(result)

		-health.groupby(health['sex'].map(sex_label))['target'].value_counts() -- one line mapping, but [] mapping can not be done here. For this use above step.

-clean_data.to_csv('clean_data.csv')  #save file
		-import os
		-os.getcwd()  #location of saved file.

	
-visualization============================================================================================
	[import matplotlib.pyplot as plt
	import seaborn as sns

	%matplotlib inline

	import warnings
	warnings.filterwarnings('ignore')

	# Set figure size initially. 10 inches width and 6 inches height
	# plt.figure(figsize=(5, 4)) #After this, any plot (Seaborn or Matplotlib) will automatically use this figure size.

	# Set figure size initially using seaborn
	sns.set(rc={'figure.figsize': (6, 4)})  #This sets the default figure size for all future plots in your notebook.
	sns.set(style="whitegrid")]
	sns.set(style='white',rc={'axes.facecolor':'black'}) #change the backgroud color to black.

-If you want to change the label in the axis.
	-plt.ylabel('thalach',rotation=0)
--------------------------------------------------------------------------------------------------------------------------------

	-Object Oriented API fig and ax object is simillar to gcf() and gca() of pyplot
	
	-sns
		jointplot : Draw multiple bivariate plots with univariate marginal distributions. Two numerical data comparision.
			plt.figure(figsize=(10,5)) #to define the size of the whole figure if subplots then including all sublots
		vis1 = sns.jointplot(data=movie, x='CriticsRating', y='AudienceRatings',kind="reg",height=4,ratio=4, label=movie.Genre.cat.categories)
    			# Height of the figure (in inches). total height
             		# Ratio of joint plot to marginal plots (height)
    			# Now control everything with plt.gcf()
		-All these control valid for any graph without fig, ax object. ie pyplot API
    			# plt.gcf().set_size_inches(5, 3)
			plt.suptitle("Critics Rating vs Audience Rating", fontsize=10)
			plt.xticks(fontsize=10, rotation=45, color='darkblue')
  			plt.yticks(fontsize=10, color='darkgreen')
			vis1.set_axis_labels(xlabel="Critics Rating (%)", ylabel="Audience Rating (%)", fontsize=12, fontweight='bold')
			plt.xlabel("Critics Rating (%)", fontsize=12, color='darkblue')
			plt.ylabel("Audience Rating (%)", fontsize=12, color='darkgreen')
			vis1.ax_joint.set_facecolor('#f5f5f5')   #To add a background color
			plt.legend()  #should also include label in plot arguments
			plt.tight_layout()
			plt.show()
		- 


		-subplots with Object Oriented API (boxplot here)
		color_dict = {
       			 'Action': 'skyblue',
        		'Drama': 'lightcoral',
        		'Comedy': 'lightgreen',
        		'Thriller': 'orange',
        		'Horror': 'purple',
        		'Romance': 'red',
        		'Adventure': 'gold'}   			
    		fig, ax = plt.subplots(1,2,figsize=(14,6))
    		sns.boxplot(data=movie, x='Genre',y='CriticsRating', palette=color_dict, ax = ax[0])
    		#Modifying the shape & size of x,y label and title & ticks.
    		ax[0].set_xlabel('Genre', fontweight='bold', fontsize=20, fontfamily='serif', color='black')
    		ax[0].set_ylabel('Critics Rating', fontweight='bold', fontsize=20, fontfamily='serif', color='black')
    		ax[0].set_xticklabels(ax[0].get_xticklabels(), fontweight='bold', fontsize=10)
    		ax[0].set_yticklabels(ax[0].get_yticklabels(),fontweight='bold', fontsize=10)

    		sns.boxplot(data=movie, x='Genre',y='AudienceRatings',palette=color_dict, ax = ax[1])
    		#Modifying the shape & size of x,y label and title & ticks.
    		ax[1].set_xlabel('Genre', fontweight='bold', fontsize=20, fontfamily='serif', color='black')
    		ax[1].set_ylabel('Audience Rating', fontweight='bold', fontsize=20, fontfamily='serif', color='black')
    		ax[1].set_xticklabels(ax[1].get_xticklabels(),fontweight='bold', fontsize=10)
    		ax[1].set_yticklabels(ax[1].get_yticklabels(),fontweight='bold', fontsize=10)
    		plt.show()

		# for simple OO API plot. 
		f, ax = plt.subplots(figsize=(8, 6))
		ax = sns.countplot(x="sex", hue="target", data=df)
		plt.show()
---------------------------------------------
		-countplot, You want to display the the numbers on the bar also.

		-mapping in groupby() & value_count(). By doing this sex instead of 0 or 1 it will display as male or female.
		target_label = {0 : 'No Heart Disease', 1 : 'Heart Disease'}
		sex_label = {0 : 'Female', 1 : 'Male'}
		# Create mapped columns (without modifying original data)
		health['sex_mapped'] = health['sex'].map(sex_label)
		health['target_mapped'] = health['target'].map(target_label)
		# Now group by mapped columns
		result = health.groupby('sex_mapped')['target_mapped'].value_counts()

		-graphical repsentation of the above groupby() function.
		
		-OBJECT ORIENTED API
-->countplot()-For x=categorical, hue=categorical.we can use hue to to count in more details. You can use mapping directly without creating the extra columns.
	--> Like sex 1 is male, 0 is female. target 1 means heart disease and 0 no heart disease.
		-# Define mappings for labels
		target_labels = {0: 'No Disease', 1: 'Heart Disease'}
		sex_labels = {0: 'Female', 1: 'Male'}	
		# Plot using mapped labels in `order` and `hue_order`
		fig, ax = plt.subplots(figsize=(6, 4))
		# When using map(), you don’t need to specify data=health in sns.countplot() because the columns are already transformed.
		sns.countplot(x=health['target'].map(target_labels), hue=health['sex'].map(sex_labels), ax=ax)
	# Add count labels(I want number of count on each bar)
		for container in ax.containers:
    			ax.bar_label(container, fmt='%d', fontsize=12, fontweight='bold')
		plt.xlabel("Target (Heart Disease Status)")
		plt.ylabel("Count")
		plt.title("Heart Disease Count by Sex")
		plt.show()

		-pyplot API
		-target_label = {0 : 'No Heart Disease', 1 : 'Heart Disease'}
		sex_label = {0 : 'Female', 1 : 'Male'}
		# When using map(), you don’t need to specify data=health in sns.countplot() because the columns are already transformed.
		sns.countplot(x=health['target'].map(target_label), hue = health['sex'].map(sex_label))
		for i in plt.gca().containers:
    			plt.gca().bar_label(i, fmt='%d', fontsize=12, fontweight='bold')
		plt.xlabel('Target(heart disese)')
		plt.ylabel('Count')
		plt.title('Heart disease between male & female')
		plt.show()



-Two subplot. One has actual numbers on the bars and another percentage.sex & target(Heart disease present or not)-both categorical.
		-1st one is count of male and female on the basis of diseasesd and non-diseasesd. 2nd one is percentage of the 1st graph.

		target_labels = {0: 'absence of heart disease', 1: 'presence of heart disease'}
		sex_label = {1: 'Male', 0: 'Female'}
		plt.figure(figsize=(13, 5))
		# 1st Subplot: Absolute Counts.
		plt.subplot(1, 2, 1)
		sns.countplot(x=health['sex'].map(sex_label),hue=health['target'].map(target_labels))
		for container in plt.gca().containers:
    			plt.gca().bar_label(container, fontsize=12)
		plt.title("Heart Disease Count by Sex")
		# 2nd Subplot: Percentage of Each Sex.
		plt.subplot(1, 2, 2)
		# Compute percentages(create new dataframe)
		health_pct = (
    			health.groupby('sex')['target']
    			.value_counts(normalize=True)  # Convert to percentage
    			.mul(100)  # Convert to percentage scale
    			.rename_axis(['sex', 'target'])  # Keep correct indexing
    			.reset_index(name='percentage'))  # Convert to DataFrame

		# Plot percentage
		sns.barplot(x=health_pct['sex'].map(sex_label),y=health_pct['percentage'],hue=health_pct['target'].map(target_labels))
		# Add labels on bars
		for container in plt.gca().containers:
    			plt.gca().bar_label(container, fmt="%.1f%%", fontsize=12)
		plt.title("Heart Disease Percentage by Sex")
		plt.ylabel("Percentage (%)")
		plt.show()

		-fig, ax = plt.subplots(figsize = (6,4))
		ax = sns.countplot(x='target', data=health, palette="Set1") #different color of the bars

-Aggregrate not count.(categorigal and Numerical)(category of product and unit sold)
-Above one is just count not aggregate. Like you have one column of 4 category product and another column having the number of unit sold.
Now if you apply above then it will give you the count I mean the number of time category repeats but we want to add values present in unit sold column
for each category

	category_sale = sales_data.groupby('category')['unit_sold'].agg(['sum', 'mean', 'std']).reset_index()
	category_sale.columns = ['category', 'total_unit_sold', 'average unit sold', 'standard devition']

	# For aggregate this is how we can get the percentage values. Percentage of unit sold per category.
	category_sale['sale_percentage'] = round((category_sale['total_unit_sold']/category_sale['total_unit_sold'].sum())*100,2)
	
	plt.subplot(1,2,1)
	sns.barplot(data= sales_data, x=category_sale['category'],y=category_sale['total_unit_sold'],palette="Set2")
	for container in plt.gca().containers:
    		plt.gca().bar_label(container, fontsize=12)
	
	plt.subplot(1,2,2)
	sns.barplot(data= sales_data, x=category_sale['category'],y=category_sale['sale_percentage'],palette="Set3")
	for container in plt.gca().containers:
    		plt.gca().bar_label(container, fmt="%.1f%%", fontsize=12)   ### To add percentage sign ###


-catplot()- For two categorical data. sex- male or female, disease yes or no. we can not use mapping here we have to create different columns.
		- here two graphs will be created one for male and another for female and each graph will provide target info.
		-target_label = {0 : 'No Heart Disease', 1 : 'Heart Disease'}
		sex_label = {0 : 'Female', 1 : 'Male'}
		health['disease_report'] = health['target'].map(target_label)
		health['gender'] = health['sex'].map(sex_label)
		g = sns.catplot(x='disease_report', col='gender',data= health,kind='count')
		plt.tight_layout()
		plt.show()

		-Without hue if you want to add count or number above bar in the graphs.
		-fig, ax = plt.subplots(figsize=(6, 4))
		ax = sns.countplot(x='target', data=health)
		# Add count labels using `bar_label`
		ax.bar_label(ax.containers[0], fmt='%d', fontsize=12, fontweight='bold')   #one liner to add numbers above graph.
		plt.show()
---------------------------------------------------
-countplot is for single variable analysis(categorical). We can use hue to another categorical attributes. 
-It is like grphical represenation of .groupby(x)[hue].value_counts()
-sns.countplot --> when need to count. Suppose yu have a attribute 'target' with two values 0 or 1. Now to count 0 and 1 we can use countplot.
		--> we can use hue to to count in more details. You can use mapping directly without creating the extra columns.
		--> Like sex 1 is male, 0 is female.
		sns.countplot(x=health['sex'], hue= health['target'])  --> here we count sex 0 and 1 and for sex 0 how many target 0 and 1 and same for sex 1.

-Categorical with counts(both same)
	income_df["Highest_Qualified_Member"].value_counts().plot(kind="bar")
	sns.countplot(data=income_df,x=income_df["No_of_Earning_Members"])

-distplot(For single variable analysis- Distribution of a continues numerical attribute)(simply counts the number of time a numer repeat)
		vis1= sns.distplot(df['InternetUsers']) --> suppose InternetUsers having different values 0 to 100, in that case we get distribution.

		-vis23 = plt.hist(clean_data['Salary']) --> same like distplot, distribution of Salary.
		-vis2 = sns.histplot(clean_data['Salary']) --> Simillar like above two but also gives count in Y axis.

		-vis2= sns.displot(df['InternetUsers'],bins=20) --> same like sns.distplot but give exact value or count in Y.

--distplot and displot can not be drawn by subplot side by side. displot will be plooted outside the subplots.
-instead use histplot inplace of displot.
	-it does not work.
	-plt.figure(figsize=(12,4))
	plt.subplot(1,2,1)
	sns.distplot(health['thalach'])
	plt.subplot(1,2,2)
	sns.displot(health['thalach'])
	plt.show()

	-It will wotk
	-plt.figure(figsize=(12,4))
	plt.subplot(1,2,1)
	sns.distplot(health['thalach'])
	plt.subplot(1,2,2)
	sns.histplot(health['thalach'])
	plt.show()

-vis5 = sns.lmplot(data=df,x='InternetUsers', y='BirthRate') --> Both are numerical data. relation b/w two numerical data attributes. Distribution

-rating_1.hist(column='rating', figsize=(10,5)) --> rating has five values 1,2,3,4,5. gives distribution in bar for values 0 to 1, 1 to 2, 2 to 3....
		-plt.hist(movie[movie.Genre=='Drama'].AudienceRatings,bins=20) --> with filter distribution of a numerical attribtes.

-stack graph. You have rating(Numerical) and genre(categorical) attributes. You want a stacked graph or distribution of rating for different genre.
		plt.hist(
    			[movie[movie.Genre==gen].AudienceRatings for gen in movie.Genre.cat.categories],
    			bins=20,
    			label=movie.Genre.cat.categories,
    			alpha=1,   #make color dull or bright
    			stacked=True)
		plt.gcf().set_size_inches(10, 6)   --> this is how we access the figure of a pyplot API
		# Add labels and title
		plt.xlabel('Audience Rating')
		plt.ylabel('Frequency')
		plt.title('Stacked Distribution of Audience Ratings by Genre')
		# Add legend
		plt.legend()
		plt.show()

-lmplot(Numerical vs Numerical) (To see the linear relation in discreate data points)
		-vis4 = sns.lmplot(data=clean_data,x='Exp',y='Salary') #Distribution of data points between two numerical attributes.
		-vis5 = sns.lmplot(data=clean_data,x='Exp',y='Salary',fit_reg=False)
		-vis6= sns.lmplot(data=movie,x='CriticsRating', y='AudienceRatings',hue='Genre',fit_reg=False)

-kdeplot(Numerical vs Numerical) (To see the distribution in other way)(can be used for single variable, numrical variable)
		-sns.set(style='white')   #background color.
		plt.figure(figsize=(8,5))  #customerize fig size before each graph.
		vis7 = sns.kdeplot(data=movie,x=movie.BudgetMillion,y=movie.AudienceRatings,fill=True,cmap='cividis',thresh=0.05)

		-sns.kdeplot(health['thalach'],shade=True,color='r') #single variable.

-jointplot(Numerical vs Numerical) (with bar distribution above lines)
		-sns.jointplot(x='age',y='thalach',data=health,hue=health['target'].map(target_labels),hue_order=target_order)

[-scatterplot(Numerical vs Numerical)
		-sns.scatterplot(x="age", y="trestbps", data=df)

-regplot(Numerical vs Numerical) (similar like joinplot but without bar distribution above lines)
		-sns.regplot(x="age", y="trestbps", data=df)]--------------for any two numerical attributes we can plot these two to check relation.

-stripplot(Numerical vs Catergorical). 
		-sns.stripplot(x=health['target'].map(target_labels), y='thalach',data=health,palette='Set2')

		-sns.stripplot(x="target", y="thalach", data=df, jitter = 0.01) -- to make distribution more narrow.

-boxplot(Numerical vs Catergorical) (X - categorical, Y - Numerical. or Single variable - numerical)
-It is used to detect outlier, know the mean of each category and dispersion or spread.
		-vis4 = sns.boxplot(data=df,x='IncomeGroup', y='BirthRate')  
			for different income group the rate of birth will be plotted like stock market box. outliner can be detected.
		-rating_1.boxplot(column='rating', figsize=(10,5)) --> Y axis relect the values for 1 to 5.

-cmap : {'viridis', 'plasma', 'inferno', 'magma', 'cividis', 'coolwarm', 'twilight','twilight_shifted', 'turbo', 'Blues', 'BuGn', 'BuPu', 'GnBu', 'Greens', 'Greys',
         'Oranges', 'OrRd', 'PuBu', 'PuBuGn', 'PuRd', 'Purples', 'RdPu', 'Reds', 'YlGn','YlGnBu', 'YlOrBr', 'YlOrRd', 'afmhot', 'autumn', 'bone', 'cool', 'copper',
         'gist_earth', 'gist_gray', 'gist_heat', 'gist_ncar', 'gist_rainbow', 'gist_stern','gist_yarg', 'gnuplot', 'gnuplot2', 'gray', 'hot', 'hsv', 'jet', 'nipy_spectral',
        'ocean', 'pink', 'prism', 'rainbow', 'seismic', 'spring', 'summer', 'terrain','winter', 'twilight_shifted', 'cubehelix', 'flag', 'brg', 'CMRmap', 'coolwarm',
         'cividis', 'magma', 'inferno', 'plasma', 'viridis', 'turbo', 'twilight'}
         
-Suppose you have two kind of rating and 7 types or genre of movies. You want to plot a heat map for each ratings(mean rating) for different genre.
	# Group data by Genre and calculate mean ratings
	audience_mean = movie.groupby('Genre')['AudienceRatings'].mean().sort_values(ascending=False).to_frame()  #.to_frame()--- series to dataframe.
	critics_mean = movie.groupby('Genre')['CriticsRating'].mean().sort_values(ascending=False).to_frame()
	# Define colors for the heatmap
	colors = ['#F93822','#FDD20E']
	# Plot two side-by-side heatmaps
	fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(6, 5)) # the gnre names comes vertically or horizontally depends on figsize
	# Heatmap 1: Audience Ratings by Genre
	plt.subplot(1, 2, 1)
	sns.heatmap(audience_mean, annot=True, cmap=colors, linewidths=0.4, linecolor='black', cbar=False, fmt='.2f')
	plt.title('Average Audience Rating by Genre')
	# Heatmap 2: Critics Ratings by Genre
	plt.subplot(1, 2, 2)
	sns.heatmap(critics_mean, annot=True, cmap=colors, linewidths=0.4, linecolor='black', cbar=False, fmt='.2f')
	plt.title('Average Critics Rating by Genre')
	# Adjust layout
	fig.tight_layout(pad=2)
	plt.show()
-Two graphs side by side. Boxplot for categorical data to numerical data or only numerical data. Object oriented API.
	fig, ax = plt.subplots(1,2,figsize=(14,6))
	sns.boxplot(data=movie, x='Genre',y='CriticsRating',ax = ax[0])
	sns.boxplot(data=movie, x='Genre',y='AudienceRatings',ax = ax[1])
	plt.show()

-violinplot same as boxplot. pyplot API(Numerical vs Catergorical or only Numerical )
	plt.figure(figsize=(14,6))
	plt.subplot(1,2,1)
	sns.violinplot(data=movie, x='Genre',y='CriticsRating')
	plt.subplot(1,2,2)
	sns.violinplot(data=movie, x='Genre',y='AudienceRatings')
	plt.show()
        

-You have three attributes. rating(numerical), Year(categorical), genre(categorical).
	you want grpahs for each genre movies and grpah is the boxplot between rating(numerical), Year(categorical).
	-pyplot API
	-plt.figure(figsize=(20,16))
	for i,gen in enumerate(movie.Genre.cat.categories):
    		plt.subplot(4,2,i+1)
    		sns.boxplot(data=movie[movie.Genre==gen],  x='Year',y='AudienceRatings')
    		plt.title(f'Year wise Audience rating for {gen} film',fontweight='bold',fontsize=20)
    		plt.xlabel('Year', fontweight='bold', fontsize=20, fontfamily='serif', color='black')
    		plt.ylabel('Audience Rating', fontweight='bold', fontsize=20, fontfamily='serif', color='black')
    		plt.xticks(fontweight='bold', fontsize=20)
    		plt.yticks(fontweight='bold', fontsize=20)
	plt.tight_layout()
	plt.show()

	-object oriented API
	-fig, axes = plt.subplots(4, 2, figsize=(12, 18))  # Adjust figsize as needed
	fig.tight_layout(pad=4.0)  # Adjust spacing between subplots
	# Flatten the axes array for easy iteration
	axes = axes.flatten()
	# Iterate over genres and create a boxplot for each
	for i, gen in enumerate(movie.Genre.cat.categories):
    		sns.boxplot(data=movie[movie['Genre'] == gen], x='Year', y='CriticsRating', ax=axes[i])
    		axes[i].set_title(f'Year-wise Critic Rating for {gen} Films')
    		axes[i].set_xlabel('Year')
    		axes[i].set_ylabel('Critic Rating')
	# Hide any unused subplots
	for j in range(len(genres), len(axes)):
    	axes[j].axis('off')
	# Display all subplots together
	plt.show()
-for two attributes or variable. One is categorical and other one is numerical.
	-sns.barplot(y='age',x='target' ,data=health)
	-sns.barplot(x=cp_pct['cp'].map(cp_label),y=cp_pct['percentage'],hue=cp_pct['target'].map(target_labels),data=health,\
            order=cp_order, hue_order=target_order)
	Here x=categorical, y= numerical, hue= categorical.
-Create the bar plot.
	-target_counts = health['target'].value_counts()
	plt.bar(x=target_counts.index, height=target_counts.values, )

-catplot()- two categorical data. sex- male or female, disease yes or no. we can not use mapping here we have to create different columns.
	-g = sns.catplot(x='disease_report', col='gender',data= health,kind='count')
	As column is gender so 1st graph will be for male and 2nd graph is for female.

-FacetGrid: You have 7 genre movies and 5 years of data. Now you want to plot graphs for each genre and each year. Total graphs 35.
	-You can plot any plot in those graphs.
	g = sns.FacetGrid(data=movie,row='Genre',col='Year',hue='Genre', height=2, aspect=1.3)
	g = g.map(sns.scatterplot,'CriticsRating','AudienceRatings')  #plot in each graph with map function.
	plt.subplots_adjust(top=0.9)
	g.fig.suptitle('Audience Ratings vs Critics Rating split by Genre and Year')
	plt.show()
	
-*When you have many numerical variables and you want to find relation among them use pairplor along with a hue(if applicable) which is categorical.
-pairplot- similar to heatmap. variable to variable plot. 
	-num_var = ['age', 'trestbps', 'chol', 'thalach', 'oldpeak', 'target' ]
	sns.pairplot(df[num_var], kind='scatter', diag_kind='hist')
	plt.show()

	-['age', 'trestbps', 'chol', 'thalach', 'oldpeak', 'target' ] plotting 6*6 graphs, each variable will have graph with 6 variables.
	-among 6, first 5 is numerical(continuos variable), last one is categorical.
	-if i use 'target' as hue then there only graphs for first 5 numerical variable ie total graphs=5*5=25 with legend or hue 'target'
	-sns.pairplot(health[num_var], kind='scatter', diag_kind='hist',hue='target')

-Dashboard(can plot 4 or 6 grpahs in row and cloumn manner).
	#Dashboard
	sns.set_style('ticks')
	f,ax = plt.subplots(2,2,figsize=(15,15))
	k1 = sns.kdeplot(movie,y='AudienceRatings',x='BudgetMillion',cmap='magma',ax = ax[0,0])
	ax[0,0].set_title('Audience Ratings vs Budget in Million')
	k1.set(xlim=(-50,250))
	# We can further modify or add color by plotting the plot twice like k2 and k2b.
	k2 = sns.kdeplot(movie,y='CriticsRating',x='BudgetMillion',cmap='Reds',thresh=0.05,ax = ax[0,1])
	k2b = sns.kdeplot(movie,y='CriticsRating',x='BudgetMillion',shade = True,shade_lowest=False,cmap='Reds',\
                  ax = ax[0,1])
	ax[0,1].set_title('Critics Ratings vs Budget in Million')
	k2.set(xlim=(-50,250))

	k3= sns.violinplot(movie[movie.Genre == 'Thriller'], x='Year', y='AudienceRatings', ax = ax[1,0])
	ax[1,0].set_title('Year wise Audience Ratings for Thriller')

	k4 = sns.violinplot(movie[movie.Genre == 'Drama'],x='Year', y='AudienceRatings', ax = ax[1,1])
	ax[1,1].set_title('Year wise Audience Ratings for Drama')
	plt.show()

-To add a verticle line in your graph.(axvline)
	plt.figure(figsize=(10, 6))
	sns.histplot(sales_data['units_sold'], bins=10, kde=True)
	plt.title('Distribution of Units Sold')
	plt.xlabel('Units Sold')
	plt.ylabel('Frequency')
	plt.axvline(mean_sales, color='red', linestyle='--', label='Mean')      
	plt.axvline(median_sales, color='blue', linestyle='--', label='Median')
	plt.axvline(mode_sales, color='green', linestyle='--', label='Mode')
	plt.legend()
	plt.show()

-To add a horizontal line.(axhline)
-Outliner graphical representation(75 and 25 percentile)
	income_df.plot(x="Mthly_HH_Income", y="Mthly_HH_Expense")

	#two ways to create upper bound and lower bound
	IQR=income_df["Mthly_HH_Expense"].quantile(0.75)-income_df["Mthly_HH_Expense"].quantile(0.25)
	lower_bound, upper_bound = income_df["Mthly_HH_Expense"].quantile(0.75) - 1.5 * IQR, income_df["Mthly_HH_Expense"].quantile(0.25) + 1.5 * IQR
	or
	col_data = income_df["Mthly_HH_Expense"].dropna()
    	Q1, Q3 = np.percentile(col_data, [25, 75])
   	IQR = Q3 - Q1
    	lower_bound, upper_bound = Q1 - 1.5 * IQR, Q3 + 1.5 * IQR

	plt.axhline(lower_bound, color='red', linestyle='--', label='Mean')
	plt.axhline(upper_bound, color='blue', linestyle='--', label='Median')

-Graphical representaton of agg()

-Suppose you have 4 qualification for the citizen and you have their income and expanditure(catergorical, numerical, numerical, more numerical attributes)
-Now you want mean, total, max - income and expanditure for each qualification---use this

	It will give mean, sum and max of both income and expanditure for each Highest_Qualified_Member unique item.
	grouped_data = income_df.groupby("Highest_Qualified_Member").agg({
    		'Mthly_HH_Income': ['mean', 'sum', 'max'],
    		'Mthly_HH_Expense': ['mean', 'sum', 'min']
	})

	print(grouped_data)

-stacked graph of mean income and expanditure for each qualification type(catergorical, numerical, numerical)

	grouped_data[('Mthly_HH_Income', 'mean')].plot(kind='bar', color='skyblue', label='Mean Income')
	grouped_data[('Mthly_HH_Expense', 'mean')].plot(kind='bar', color='lightcoral', label='Mean Expense')

	# Add title and labels
	plt.title('Mean Monthly Income vs. Expense by Qualification')
	plt.xlabel('Highest Qualified Member')
	plt.ylabel('Amount')
	plt.legend()
	plt.xticks(rotation=45)  # Rotate x-axis labels if needed
	plt.show()

-stacked graph of total income and expanditure for each qualification type(catergorical, numerical, numerical)

	grouped_data[[('Mthly_HH_Income', 'sum'), ('Mthly_HH_Expense', 'sum')]].plot(kind='bar', stacked=True, figsize=(10, 6))

	# Add title and labels
	plt.title('Sum of Monthly Income and Expense by Qualification')
	plt.xlabel('Highest Qualified Member')
	plt.ylabel('Total Amount')
	plt.legend(['Total Income', 'Total Expense'])   --- how to add legend without adding label withion the plot 1st line
	plt.xticks(rotation=45)
	plt.show()

-Plot max income and min expense by Highest_Qualified_Member(catergorical, numerical, numerical)
	grouped_data[('Mthly_HH_Income', 'max')].plot(kind='line', marker='o', color='green', label='Max Income')
	grouped_data[('Mthly_HH_Expense', 'min')].plot(kind='line', marker='s', color='red', label='Min Expense')

	# Add title and labels
	plt.title('Max Income vs. Min Expense by Qualification')
	plt.xlabel('Highest Qualified Member')
	plt.ylabel('Amount')
	plt.legend()
	plt.grid(True)
	plt.show()

	-'Movie rating analysis'- for more details.

-streamlit app
	-for details graphs view see
	-C:\Users\USER\Documents\Python\Nareshit data analysis\Data analysis\MOVIE RATINGS _ ADVANCE VISUALIZATION _ EDA 1\Movie analysis with front end by streamlit

	-@st.cache_data
	def load_data():
		movie = pd.read_csv(r'C:\Users\USER\Documents\Python\Nareshit data analysis\Data analysis\MOVIE RATINGS _ ADVANCE VISUALIZATION _ EDA 1\Movie analysis with front end by streamlit\Movie-Rating.csv')
    		movie.columns=['Film', 'Genre', 'CriticsRating', 'AudienceRatings', 'BudgetMillion','Year']
    		for col in movie.columns:
        		if movie[col].dtype == 'object':
            			movie[col] = movie[col].astype('category')
    		movie['Year']=movie['Year'].astype('category')
    		return movie

	-movie = load_data()

	-st.image("movie_logo.webp")
	st.title("Data analysis of movies by Raja Debnath")
	st.header("This is an EDA on the movies Dataset")
	st.write('First few rows of the dataset: ')
	st.dataframe(movie.head())

	-#check_for_empty_cell
	st.subheader('Missing Values')
	missing_data = movie.isnull().sum()
	st.write(missing_data)

	-# EDA Section
	st.subheader('Statistical Summary of the Data')
	st.write(movie.describe().T)
	# st.write(movie.dtypes)  # .info() is not working.

	-st.info("Visualization")

	-if st.checkbox('Boxplot for Genre wise Critics Rating & Audience Ratings'): #if tick the checkbox then only it appears whatever added inside if.

	-st.subheader('Distribution of Critics Rating & Audience Ratings') --> before draw any graph.
	st.pyplot(vis1.figure) --> if the graph is being drawn with an variable
	st.pyplot(plt.gcf()) --> for pyplot API
	st.pyplot(fig) --> Object oriented API.
	st.pyplot(f) --> Object oriented API. same like above one.

	-# Conclusion Section
	st.subheader('Key Insights')
	insights = """
	- Thriller, Drama, Adventure are the top rating movies.
	- Audiance rating are more generous than critic rating.
	- Audiance rating & critic rating have liner relation.
	- Movies having higher Audiance rating, are likely to be watched by audiance.
	- Horror movies have bad impact on audiance.
	"""
	st.write(insights)

NUMPY:
	